package proxy

import (
	"bytes"
	"crypto/ecdsa"
	"crypto/sha256"
	"encoding/base64"
	"errors"
	"fmt"
	"net"
	"strings"
	"time"

	"github.com/akmalfairuz/legacy-version/legacyver/proto"
	"github.com/go-jose/go-jose/v4"
	"github.com/go-jose/go-jose/v4/jwt"
	"github.com/sandertv/gophertunnel/minecraft/protocol"
	"github.com/sandertv/gophertunnel/minecraft/protocol/login"
	"github.com/sandertv/gophertunnel/minecraft/protocol/packet"
	"github.com/sandertv/gophertunnel/minecraft/text"
)

var (
	ErrOutdatedClient = errors.New("outdated client")
	ErrOutdatedServer = errors.New("outdated server")
)

type ProxyConn struct {
	conn        packetReader
	authEnabled bool

	enc *packet.Encoder
	dec *packet.Decoder

	compression packet.Compression

	identityData login.IdentityData
	clientData   login.ClientData

	// privateKey is the private key of this end of the connection. Each connection, regardless of which side
	// the connection is on, server or client, has a unique private key generated.
	privateKey *ecdsa.PrivateKey
	// salt is a 16 byte long randomly generated byte slice which is only used if the Conn is a server sided
	// connection. It is otherwise left unused.
	salt []byte

	nethernet bool

	loginDone bool

	hdr *packet.Header

	pool packet.Pool

	protocolId int32

	loginPk *packet.Login

	deferredPackets [][]byte

	requestNetworkSettingsHandled bool
}

func NewProxyConn(conn packetReader, isNethernet bool) *ProxyConn {
	pool := packet.NewServerPool()
	for i, pk := range packet.NewClientPool() {
		pool[i] = pk
	}
	c := &ProxyConn{conn: conn, nethernet: isNethernet, hdr: &packet.Header{}, enc: packet.NewEncoder(conn), dec: packet.NewDecoder(conn), pool: pool, compression: packet.FlateCompression}
	c.dec.DisableBatchPacketLimit()
	return c
}

func (c *ProxyConn) IdentityData() login.IdentityData {
	return c.identityData
}

func (c *ProxyConn) SetAuthEnabled(enabled bool) {
	c.authEnabled = enabled
}

func (c *ProxyConn) ReadLoop() error {
	if c.nethernet {
		go func() {
			time.Sleep(3 * time.Second) // hack to fix requestnetworksettings occasionally not being received
			if !c.requestNetworkSettingsHandled {
				c.handleRequestNetworkSettings()
			}
		}()
	}
	for {
		pks, err := c.ReadPackets()
		if err != nil {
			c.conn.Close()
			return err
		}
		for _, pkBytes := range pks {
			packetData, err := ParseData(pkBytes)
			if err != nil {
				c.conn.Close()
				return err
			}
			if pkFunc, ok := c.pool[packetData.h.PacketID]; ok {
				pk := pkFunc()
				if err := decodePacket(pk, packetData.payload); err != nil {
					c.conn.Close()
					return err
				}
				switch pk := pk.(type) {
				case *packet.RequestNetworkSettings:
					c.handleRequestNetworkSettings()
				case *packet.NetworkSettings:
					c.handleNetworkSettings(pk)
				case *packet.Login:
					if err := c.handleLogin(pk); err != nil {
						return err
					}
					if c.nethernet {
						c.loginDone = true
						return nil
					}
				case *packet.ServerToClientHandshake:
					if err := c.handleServerToClientHandshake(pk); err != nil {
						return err
					}
					c.loginDone = true
					return nil
				case *packet.ClientToServerHandshake:
					if err := c.handleClientToServerHandshake(); err != nil {
						return err
					}
					c.loginDone = true
					return nil
				case *packet.Disconnect:
					return errors.New(pk.Message)
				case *packet.PlayStatus:
					switch pk.Status {
					case packet.PlayStatusLoginSuccess, packet.PlayStatusPlayerSpawn:
						c.deferredPackets = append(c.deferredPackets, pkBytes)
						c.loginDone = true
						return nil
					case packet.PlayStatusLoginFailedClient:
						return ErrOutdatedClient
					case packet.PlayStatusLoginFailedServer:
						return ErrOutdatedServer
					default:
						return fmt.Errorf("play status: %d", pk.Status)
					}
				default:
					c.deferredPackets = append(c.deferredPackets, pkBytes)
				}
			}
		}
	}
}

func (c *ProxyConn) ClientData() login.ClientData {
	return c.clientData
}

func (c *ProxyConn) Protocol() int32 {
	return c.protocolId
}

func decodePacket(pk packet.Packet, b *bytes.Buffer) (err error) {
	defer func() {
		if rErr := recover(); rErr != nil {
			if errr, ok := rErr.(error); ok {
				err = errr
			}
			err = errors.New("unexpected error")
		}
	}()
	r := protocol.NewReader(b, 0, true)
	pk.Marshal(r)
	return nil
}

func (c *ProxyConn) ReadPackets() (packets [][]byte, err error) {
	if len(c.deferredPackets) > 0 && c.loginDone {
		def := c.deferredPackets
		c.deferredPackets = [][]byte{}
		return def, nil
	}
	return c.dec.Decode()
}

func (c *ProxyConn) WritePackets(pks [][]byte) error {
	return c.enc.Encode(pks)
}

func (c *ProxyConn) Close() error {
	return c.conn.Close()
}

// handleLogin handles an incoming login packet. It verifies and decodes the login request found in the packet
// and returns an error if it couldn't be done successfully.
func (conn *ProxyConn) handleLogin(pk *packet.Login) error {
	conn.protocolId = pk.ClientProtocol
	// The next expected packet is a response from the client to the handshake.
	//conn.expect(packet.IDClientToServerHandshake)
	var (
		err        error
		authResult login.AuthResult
	)
	conn.identityData, conn.clientData, authResult, err = login.Parse(pk.ConnectionRequest)
	if err != nil {
		return fmt.Errorf("parse login request: %w", err)
	}

	// Make sure the player is logged in with XBOX Live when necessary.
	if !authResult.XBOXLiveAuthenticated && conn.authEnabled {
		_ = conn.WritePacket(&packet.Disconnect{Message: text.Colourf("<red>You must be logged in with XBOX Live to join.</red>")})
		return fmt.Errorf("client was not authenticated to XBOX Live")
	}
	if !conn.nethernet {
		if err := conn.enableEncryption(authResult.PublicKey); err != nil {
			return fmt.Errorf("enable encryption: %w", err)
		}
	}
	return conn.handleClientToServerHandshake()
}

// handleRequestNetworkSettings handles an incoming RequestNetworkSettings packet. It returns an error if the protocol
// version is not supported, otherwise sending back a NetworkSettings packet.
func (conn *ProxyConn) handleRequestNetworkSettings() error {
	conn.requestNetworkSettingsHandled = true
	if err := conn.WritePacket(&packet.NetworkSettings{
		CompressionThreshold: 1,
		CompressionAlgorithm: conn.compression.EncodeCompression(),
	}); err != nil {
		return fmt.Errorf("send NetworkSettings: %w", err)
	}
	conn.enc.EnableCompression(conn.compression)
	conn.dec.EnableCompression(1024 * 1024 * 1024)
	return nil
}

// handleNetworkSettings handles an incoming NetworkSettings packet, enabling compression for future packets.
func (conn *ProxyConn) handleNetworkSettings(pk *packet.NetworkSettings) error {
	alg, ok := packet.CompressionByID(pk.CompressionAlgorithm)
	if !ok {
		return fmt.Errorf("unknown compression algorithm %v", pk.CompressionAlgorithm)
	}
	conn.enc.EnableCompression(alg)
	conn.dec.EnableCompression(1024 * 1024 * 1024)
	if conn.loginPk != nil {
		conn.WritePacket(conn.loginPk)
	}
	return nil
}

// enableEncryption enables encryption on the server side over the connection. It sends an unencrypted
// handshake packet to the client and enables encryption after that.
func (conn *ProxyConn) enableEncryption(clientPublicKey *ecdsa.PublicKey) error {
	signer, _ := jose.NewSigner(jose.SigningKey{Key: conn.privateKey, Algorithm: jose.ES384}, &jose.SignerOptions{
		ExtraHeaders: map[jose.HeaderKey]any{"x5u": login.MarshalPublicKey(&conn.privateKey.PublicKey)},
	})
	// We produce an encoded JWT using the header and payload above, then we send the JWT in a ServerToClient-
	// Handshake packet so that the client can initialise encryption.
	serverJWT, err := jwt.Signed(signer).Claims(saltClaims{Salt: base64.RawStdEncoding.EncodeToString(conn.salt)}).Serialize()
	if err != nil {
		return fmt.Errorf("compact serialise server JWT: %w", err)
	}
	if err := conn.WritePacket(&packet.ServerToClientHandshake{JWT: []byte(serverJWT)}); err != nil {
		return fmt.Errorf("send ServerToClientHandshake: %w", err)
	}

	// We first compute the shared secret.
	x, _ := clientPublicKey.Curve.ScalarMult(clientPublicKey.X, clientPublicKey.Y, conn.privateKey.D.Bytes())

	sharedSecret := append(bytes.Repeat([]byte{0}, 48-len(x.Bytes())), x.Bytes()...)

	keyBytes := sha256.Sum256(append(conn.salt, sharedSecret...))

	// Finally we enable encryption for the encoder and decoder using the secret key bytes we produced.
	conn.enc.EnableEncryption(keyBytes)
	conn.dec.EnableEncryption(keyBytes)

	return nil
}

// handleClientToServerHandshake handles an incoming ClientToServerHandshake packet.
func (conn *ProxyConn) handleClientToServerHandshake() error {
	// The next expected packet is a resource pack client response.
	return nil
}

func (conn *ProxyConn) WritePacket(pk packet.Packet) error {
	b := bytes.NewBuffer(nil)
	conn.hdr.PacketID = pk.ID()
	_ = conn.hdr.Write(b)

	io := proto.NewWriter(protocol.NewWriter(b, 0), conn.protocolId)
	pk.Marshal(io)

	return conn.WritePackets([][]byte{b.Bytes()})
}

// saltClaims holds the claims for the salt sent by the server in the ServerToClientHandshake packet.
type saltClaims struct {
	Salt string `json:"salt"`
}

// handleServerToClientHandshake handles an incoming ServerToClientHandshake packet. It initialises encryption
// on the client side of the connection, using the hash and the public key from the server exposed in the
// packet.
func (conn *ProxyConn) handleServerToClientHandshake(pk *packet.ServerToClientHandshake) error {
	tok, err := jwt.ParseSigned(string(pk.JWT), []jose.SignatureAlgorithm{jose.ES384})
	if err != nil {
		return fmt.Errorf("parse server token: %w", err)
	}
	//lint:ignore S1005 Double assignment is done explicitly to prevent panics.
	raw, _ := tok.Headers[0].ExtraHeaders["x5u"]
	kStr, _ := raw.(string)

	pub := new(ecdsa.PublicKey)
	if err := login.ParsePublicKey(kStr, pub); err != nil {
		return fmt.Errorf("parse server public key: %w", err)
	}

	var c saltClaims
	if err := tok.Claims(pub, &c); err != nil {
		return fmt.Errorf("verify claims: %w", err)
	}
	c.Salt = strings.TrimRight(c.Salt, "=")
	salt, err := base64.RawStdEncoding.DecodeString(c.Salt)
	if err != nil {
		return fmt.Errorf("decode ServerToClientHandshake salt: %w", err)
	}

	x, _ := pub.Curve.ScalarMult(pub.X, pub.Y, conn.privateKey.D.Bytes())
	// Make sure to pad the shared secret up to 96 bytes.
	sharedSecret := append(bytes.Repeat([]byte{0}, 48-len(x.Bytes())), x.Bytes()...)

	keyBytes := sha256.Sum256(append(salt, sharedSecret...))

	// Finally we enable encryption for the enc and dec using the secret pubKey bytes we produced.
	conn.enc.EnableEncryption(keyBytes)
	conn.dec.EnableEncryption(keyBytes)

	conn.WritePacket(&packet.ClientToServerHandshake{})

	return nil
}

type packetReader interface {
	net.Conn
	ReadPacket() ([]byte, error)
}
